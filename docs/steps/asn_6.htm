<!---                               +                                      --->
<html>
<head>
<title>[ AmberSkyNet VR ]</title>
<link rel=stylesheet type=text/css href=../ambernet.css>
</style>
</head>
<body>
<center>
<table width=80%><tr><td>
<h1 class=header1 align=center>[ AmberSkyNet VR ]</h1>
<blockquote>
</blockquote>

<p>Из трёх переменных в разделе [Path] ini-файла 
<b>DataPath</b>, <b>PluginsPath</b>, <b>LogPath</b> на сегодняшний момент
в движке не используется только одна - <b>DataPath</b>.
А это значит - пора делать класс виртуальной файловой системы.</p>


<h3 class=header3 align=center>IFileSystem</h3>
<p>Для начала - составим интерфейс:</p>

<pre><b>
class IFileSystem {
public:
<font color=green>// добавить путь к файлам</font>
virtual bool AddPath(const std::string& Path, bool Recursive)=0;
<font color=green>// получить файл</font>
virtual IFile *GetFile(const std::string& FileName)=0;
<font color=green>// добавляем источник файлов</font>
<font color=green>// если FileSource=NULL - загружаем через систему плагинов</font>
<font color=green>// иначе просто запоминаем с именем FileSourceName</font>
virtual bool AddFileSource (const std::string& FileSourceName,IFileSource *FileSource)=0;
};
</b></pre>

<p>Функция AddPath добавляет путь к папке, в которой могут находиться
файлы, получаемые из файловой системы при выполнении функции GetFile.<br>
Функция AddFileSource позволяет добавить в файловую систему свои свои источники файлов. Например - менеджер сети
может добавить источник чтения файла по какому-либо сетевому протоколу.</p>

<h3 class=header3 align=center>IFileSource</h3>
<p>Интерфейс IFileSource предназначен для реализации различных источников
данных - файлы, хранящиеся напрямую в файловой системе, в архивах, в сети.
Для каждого типа источника можно будет написать свой интерфейс и работа
с ним будет одинакова в пределах видимости виртуальной файловой системы, 
а значит, и движка.

<pre><b>class IFileSource {
public:
virtual IFile *LoadFile(const std::string& FileName)=0;
virtual void AddPath(const std::string& PathName, bool Recursive)=0;
};
</b></pre>


<h3 class=header3 align=center>IFile</h3>
<p>При выполнении команды GetFile менеджера файловой системы мы получаем указатель на экземпляр класса,
скрывающегося за интерфейсом IFile.
Из-за наличия сетевого режима файл может быть в нескольких состояниях, например-
не только на диске или в памяти, но и в процессе загрузки с сервера, причём
на сервере его может не оказаться, но движок не может ждать пока сервер
перешлёт все требуемые файлы на клиента, а 
должен отрисовывать то, что уже есть в наличии в локальной директории кэша.
Отсюда возможные состояния файла несколько специфичны:

<pre><b>enum asn_File_State{
ASN_FILE_NONE, <font color=green>//состояния нет (файл закрыт)</font>
ASN_FILE_NOT_FOUND, <font color=green>//файл не найден (например, на сервере)</font>
ASN_FILE_DISK_OPEN, <font color=green>//файл открыт на диске</font>
ASN_FILE_DISK_IN_MEM, <font color=green>//файл загружен в память и закрыт на диске</font>
ASN_FILE_WAIT, <font color=green>//файл ожидает загрузки</font>
ASN_FILE_LOADING, <font color=green>//файл в процессе загрузки</font>
};
</b></pre>

А сам интерфейс класса файл выглядит следующим образом:
<pre><b>class IFile{
public:
<font color=green>//имя файла</font>
virtual std::string GetName();
<font color=green>//состояние файла</font>
virtual asn_File_State GetState()=0;
<font color=green>// открыть файл</font>
virtual asn_File_State FileOpen()=0;
<font color=green>// закрыть файл</font>
virtual void FileClose()=0;
<font color=green>// загрузить файл в память, на выходе - указатель на область</font>
virtual void *LoadInMem()=0;
<font color=green>// освободить память</font>
virtual void FreeMem()=0;
<font color=green>// передвинуть на позицию</font>
virtual void Seek(unsigned int Position, int From)=0;
<font color=green>// получить размер файла в байтах;</font>
virtual unsigned int GetSizeInBytes()=0;
<font color=green>// прочитать часть файла в буфер</font>
virtual void ReadBuf(void *buf, unsigned int size)=0;
};
</b></pre>
Мы может узнать состояние файла при помощи функции GetState(), а изменять состояния файла выполнением функций FileOpen,FileClose,LoadInMem.<br>
Вообще мне не очень нравится, конечно, что функционал как бы оказался
размазаным по классам IFile и IFileSystem, однако я стремился сделать
файлы более автономными и внешне не зависящими от файловой системы -
иначе бы с появлением в IFileSystem функций наподобие CloseFile пришлось бы
делать поиск по всем открытым файлам для нахождения нужного файла, который бы
следовало закрыть.

<h3 class=header3 align=center>CFileSystem</h3>

<p>Реализация CFileSystem при создании читает переменную окружения <b>[Paths]DataPath</b>
и запоминает её у себя под именем SandBox :) Все данные, которые доступны
для чтения файловой системой располагаются не выше указанной папки.
Далее в переменных окружения находится переменная <b>[FileManager]DataReader</b>,
в которой перечислены через запятую все источники файлов (т.е. менеджеры загрузки
файлов из локального диска и архивов, например), используемые
при данном запуске системы. Пытаемся загрузить их при помощи системы
плагинов, после чего посылаем туда значение локальной перменной SandBox.<br>
При вызове функции GetFile менеджер файловой системы CFileSystem
перебирает все источники из своего списка. Если ни один источник
не может загрузить этот файл менеджер возвращет NULL. Если файл был
загружен каким-то из источников менеджер запоминает его в своем списке
и возвращает указатель на этот файл.<br>
В деструкторе CFileSystem все открытые файлы закрываются и список файлов очищается.
То же самое происходит и со списком источников файлов.</p>


<h3 class=header3 align=center>CFileSystemASN</h3>
<p>Класс-надстройка над CFileSystem, добавляющая небольшой функционал - 
прежде начала поиска файла по всем известным путям он ищется в папке
common. Это позволит нам использовать одни и те же ресурсы для разных миров,
например - текстуры, звуки. Ах да, я же забыл вас ознакомить
со структурой папки data. Так вот:
 
 <ul>
  <li><b>data/</b>    - папка для используемых данных
   <ul>
    <li><b>common/</b> - папка для общих ресурсов всех миров
    <li><b>local/</b>  - папка для миров, расположенных на локальной машине
   <ul>
    <li><b>HOME</b> - основной стартовый каталог
    <li><b>...</b>
   </ul>
  </ul>
 </ul>
</p>

<p>Менеджеры миров (которые на данный момент еще не реализованы) обращаясь к файловой системе будут использовать имена начинающиеся
с типа менеджера (local/net) и имени мира (например, HOME).
Скажем, если менеджер локального мира HOME захочет взять файл start.lua из своих
ресурсов он обратится к файловой системе с запросом GetGile("local/HOME/start.lua");<br>
Впрочем, если не требуется поддержка нескольких миров, вполне можно использовать 
менеджер файловой системы CFileSystem, который делает обычный поиск, без дополнительного
поиска в папке common.

<h3 class=header3 align=center>CFileSource, CFile</h3>
<p>Класс источника файлов CFileSource реализует возможность чтения файлов напрямую
из физической файловой системы. При вызове функции LoadFile мы пытаемся найти и
открыть файл по всем путям из списка, который формируется при выполнении функции AddPath.
Если такой файл не найден - возвращем NULL, если найдет - создаём файл CFile,
заполняем все необходимые в нём значения и возвращем указатель на него.
Класс CFileSource "видит" все приватные переменные класса CFile,
т.к. он является дружественным классу CFile.</p>

<p>Класс файла CFile предоставляет доступ к файлу физической файловой системы
и выполняет некоторые дисковые операции над ним - чтение из файла, загрузка в память.

<h3 class=header3 align=center>CFileSourceZIP, CFileZIP</h3>
<p>Класс источника файлов CFileSourceZIP реализует возможность чтения файлов 
из архивов формата ZIP. При выполнении функции AddPath мы перебираем
все имеющиеся в указанной директории файлы и пытаеся загрузить их как ZIP-архив.
В случае удачи - читаем список файлов, хранящихся в данном архиве и запоминаем
его. При вызове функции LoadFile проводится поиск в списке известных
нам хранящихся в архиве файлов и в случае если такой файл найден - создаём
экземпляр класса CFileZIP, устанавливаем в нём необходимые переменные и
отправляем указатель на него.<br>

Класс файла CFileZIP предоставляет доступ к файлу, хранящемся
в ZIP-архиве и позволяет загружать его в память.</p>

<h3 class=header3 align=center>Взаимодействие с менеджером файловой системы</h3>
<p>Engine после разбора ini-файла читает значение переменной
<b>[Modules]FileManager</b> и пытается загрузить через систему плагинов
менеджер файловой системы с таким именем. 
Полученный указатель запоминается в указателях окружения с именем <b>FileManager</b>,
получить извне доступ к нему можно например вот так:
<pre><b>(IFileSystem*)ENGINE->GetPtrParam("FileManager");
</b></pre>
или воспользоваться макросами, определёнными в файле IFileSystem.h
<pre><b>IFile *myFile=FILER->GetFile("test.txt");</b></pre>
Только нужно не забывать, что даже если мы получили экземпляр класса
IFile, он может быть в состоянии ASN_FILE_NOT_FOUND или
в состояниях отложенной загрузки - ASN_FILE_WAIT, ASN_FILE_LOADING.
Поэтому после получения указателя на файл неплохо было бы проверять
его состояние функцией GetState().
</p>

<p>В дальнейшем, если в движке появятся менеджеры миров,
функционал классов файловой системы будет возможно изменен, чтобы поиск
происходил только среди общих ресурсов и ресурсов текущего мира.

<p align=center><img src=asn_6_1.png></p>

<h3 class=header3 align=center>Изменения в исходниках</h3>
<p><b>include/:</b> Добавлен интерфейсы IFile.h, IFileSource.h, IFileSystem.h</p>

<p><b>src/asnMain/:</b>  демонстрация работы менеджера файловой системы
</p>

<p><b>src/asnEngine/:</b> добавлена инициализация менеджера файловой системы
</p>

<p><b>src/asnFileSystem/:</b> Новый плагин - менеджер файловой системы.
Чтение с диска, из архивов ZIP.
</p>

<p>Исходники этого шага выложены в SVN. Скачать их можно набрав команду:
<pre>
<b>svn co https://svn.sourceforge.net/svnroot/ambernet/tags/AmberSkyNet-0.6 ambernet_0.6</b>
</pre>

</table>
<div>Powered by:
<A href="http://sourceforge.net"><IMG align=center src="http://sourceforge.net/sflogo.php?group_id=121759&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo" /></A>
</div>

</body>
</html>