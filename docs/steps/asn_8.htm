<!---                               +                                      --->
<html>
<head>
<title>[ AmberSkyNet VR ]</title>
<link rel=stylesheet type=text/css href=../ambernet.css>
</style>
</head>
<body>
<center>
<table width=80%><tr><td>
<h1 class=header1 align=center>[ AmberSkyNet VR ]</h1>

<blockquote>
   - В этом большом ящике -  питание,  а  в  меньшем  -  мир!  В  точности
такусенький, как я обещал милостивому королю, -  анизотропный,  с  особыми
точками, в которых можно переключать бег времени, а доступ к  этим  точкам
равный и всеобщий. Измыслили мы, государь, и несколько персон,  которые  в
будущем помогут нам в опробовании следующих вселенных...  <br>
   - А как туда заглянуть? - спросил король, присматриваясь к  хлопотливой
суете Клапауция и мешая  ему,  потому  что  королевские  ноги  путались  в
проводах.<br>
   - Сейчас мы устроим времянку. Поставим на  экзистоскоп  псевдокристалл,
лазерный сигнал каскадно усилим  на  выходе,  ну,  а  дальше  уже  обычным
способом, через проектор, скажем, на эту стенку...<br>
(Станислав Лем. "Повторение")
</blockquote>

<p>Думаю, пора начинать творить цифровые миры. Сейчас-то у нас всё в
прикладной программе обрабатывается -
создание сцены, заполнение её элементами, движение и отрисовка - всё "вручную". Оно, конечно,
не так уж и плохо - можно написать свою игру руками, используя из движка только события и 
функции отрисовки, но можно и упростить процесс для тех, кто не очень хочет разбираться
с загрузкой материалов и моделей из файлов, а также с программированием динамического
заполнения сцены этими моделями.
</p>

<h3 class=header3 align=center>IWorld и его реализация CWorldSimple</h3>

<p>Напишем для начала интерфейсный класс мира с функциями заполнения элементами и отрисовки.
А потом - плагин простейшего мира SimpleWorld, который будет просто отрисовывать всё,
что в него напихали, без фильтрации по пирамиде видимости, оптимизации по BSP, Octree, итп.
Для начала...
</p>

<pre><b>class IWorld: public BaseObject {
public:
IWorld(IEngine *_Engine):BaseObject(_Engine){};
virtual ~IWorld(){}

virtual bool Draw()=0;
virtual bool Update(float tms)=0;

virtual INode *getNode( UINT id )=0;<span class=comment> //получить ноду с номером id</span>
virtual bool delNode( UINT id )=0;<span class=comment> //уничтожаем ноду с номером id в мире</span>
virtual UINT addNode( INode* node )=0;<span class=comment>//добавляем в мир внешнюю ноду, на выходе получаем её id в мире</span>

virtual UINT createNode( const std::string& InitString )=0;<span class=comment>// создаём элемент сцены</span>

virtual INode *findNode( const std::string& InitString )=0;<span class=comment> //найти ноду с именем Name; не у всех нод есть имена</span>

};</b></pre>

<p>Функция сreateNode позволяет создать узел сцены по входной информации.
Можно, например, написать класс некоей RPG-игры, в котором имеется заранее заданый набор
NPC-персонажей. При помощи функции CreateNode( "Goblin,10,5" ) мы установим в ячейку с координатами
10,5 NPC типа Goblin.</p>

<p>Функция addNode позволяет добавить в мир узел сцены, созданный извне. Мы сохраняем возможность
заполнения мира "руками", из внешней программы.</p>

<p>Функция delNode удаляет из мира узел с номером id и все его дочерние узлы.</p>

<p>Функции getNode и findNode позволяют нам получить указатель на узел по его номеру и имени.
Не все ноды могут иметь имя ( оно устанавливается в ноде вызовом функции node->SetParam("Name", node_name); )
</p>

<p>Реализация класса CWorldSimple сохраняет ноды в двух списках - std::vector для всех нод
и std::map для нод, имеющих имя.<br>
Первая созданная или добавленная в мир нода становится корневой, к которой будут присоединены все
остальные ноды. При вызове фукнций Draw и Update мы просто вызываем у корневой ноды
методы Draw и Update, не заботясь о том, что в ней есть...</p>

<h3 class=header3 align=center>INode</h3>

<p>Как видно выше, в нашем классе мира используется интерфейсный класс INode - класс узла сцены.
Привёдем заголовочный файл, показывающий этот интерфейс:
</p>

<pre><b>class INode: public BaseObject {
public:
INode(IEngine *_Engine):BaseObject(_Engine){load_all=false;};
virtual ~INode(){}

virtual bool Draw()=0;<span class=comment>//узел отрисовывает себя в сцене</span>
virtual bool Update(float tms)=0;<span class=comment>//узел изменяется по времени на tms</span>
virtual bool LoadResource()=0; <span class=comment>//узел пытается загрузить необходимые для себя ресурсы.. 
false - если все ресурсы для ноды удалось загрузить</span>

virtual UINT getID(){return id;} <span class=comment>// возвращение уникального для мира ID ноды</span>

virtual UINT addNode(INode* node)=0;<span class=comment>// добавить дочерний узел</span>
virtual UINT delNode(UINT num)=0;<span class=comment>// отсоединить дочерний узел, но из мира он не удалится!</span>
virtual INode *getParentNode(){return ParentNode};<span class=comment>//получить родительский узел</span>
virtual NodeList_typ& getNodeList()=0;<span class=comment>//получить список дочерних нод</span>

<span class=comment>// функции установки и чтения значений вместо самих параметров в public-секции
// т.к. внутри реализации класса INode они могут хранится совсем не в виде CVector
// (а например в виде матрицы преобразований)</span>
virtual void setSize(const CVector& Size)=0;<span class=comment>//размеры элемента</span>
virtual void setCenterPoint(const CVector& CenterPoint)=0;<span class=comment>//точка центра (повороты, отрисовка, итп)</span>
virtual void setPos(const CVector& Pos)=0;<span class=comment>//Позиция</span>
virtual void setRot(const CVector& Rot)=0;<span class=comment>//Угол поворота</span>

<span class=comment>//аналогично, для чтения</span>
virtual CVector& getSize()=0;
virtual CVector& getCenterPoint()=0;
virtual CVector& getPos()=0;
virtual CVector& getRot()=0;

protected:
INode *ParentNode;<span class=comment>//ссылка на родительскую INode</span>
bool load_all;<span class=comment>// все ли ресурсы для данного объекта загружены</span>
};

</b></pre>

<p>Класс составлялся с учётом того, чтобы с одной стороны обеспечить достаточно удобную автономную
работу из прикладной программы,
а с другой стороны - такую же удобную работу под управлением менеджера мира.</p>

<p>Класс CNode реализует основную функциональность по добавлению, удалению и отрисовке 
дочерних узлов сцены, по установке координат и углов узла итп.
Сам по себе он ничего не отрисовывает на экране, но может служить хранилищем группы узлов сцены.
От него же будет удобно наследовать реализацию других классов узлов сцены, например,
сейчас от него наследуется класс CNode3ds, функционал которого сосредоточен только на
отрисовке 3ds-моделей.
</p>

<h3 class=header3>Немного о менеджере ресурсов</h3>

<p>В предыдущей реинкарнации AmberSkyNetVR менеджера ресурсов как такового не было, поэтому
приходилось идти на некоторые ухищрения чтобы нужные объекты по два раза не 
создавались или загружались. В этой версии будет всё немного по-другому - 
если узлу сцены понадобится какой-то ресурс, то он сначала поищет его в кэше ресурсов,
и если не обнаружит такого, то создаст его. В менеджере ресурсов у меня хранятся
собственно, не ресурсы, загруженные с диска, а некие объекты. Таким образом, например,
класс CNode3ds может запомнить в кэше экземпляр класса модели Model3ds с загруженной
в него моделью.
</p>

<p>Интерфейс менеджера ресурсов выглядит примерно так:</p>
<b><pre>
class IResourceSystem{
public:
IResourceSystem(){}
~IResourceSystem(){}

<span class=comment>// устанавливаем новый ресурс</span>
virtual bool SetResource(const std::string& Type,
     const std::string& Name, BYTE* Resource, UINT Res_size )=0;
<span class=comment>// берём ресурс</span>
virtual BYTE *GetResource(const std::string& Type, const std::string& Name)=0;
<span class=comment>// избавляемся от ресурса</span>
virtual bool ReleaseResource(const std::string& Type, const std::string& Name)=0;

<span class=comment>// устанавливаем новый объект</span>
virtual bool SetObject(const std::string& Type,
     const std::string& Name, IasnObject *resObject)=0;
<span class=comment>// берём ресурс</span>
virtual IasnObject *GetObject(const std::string& Type, const std::string& Name)=0;
<span class=comment>// избавляемся от ресурса</span>
virtual bool ReleaseObject(const std::string& Type, const std::string& Name)=0;

};
</pre></b>

<p>Указатель на менеджер ресурсов хранится в глобальных указателях движка и может быть
получен вот так:<br>
<b>ENGINE->GetPtrParam("ResourceSystem")</b><br>
Или же можно воспользоваться макросом RESOURSER объявленным в IResourceSystem.h
</p>

<h3 class=header3>CNode3ds и CModel3ds</h3>
<p>Класс CNode3ds реализует отрисовку моделей формата 3ds.
Он создаёт в системе ресурсов экземпляр файла CModel3ds, который используя библиотеку
l3ds ( copyright (c) 2001-2002 Lev Povalahev ) конвертит 3ds-модель в набор мешей и материалов
и сохраняет их у себя.</p>
<p>Зачем нужен класс CModel3ds и почему бы не хранить меши и материалы в самом классе?
Ну, например, у нас на сцене десять объектов имеют одну и ту же 3ds-модель.
Нам достаточно один раз создать класс CModel3ds с набором мешей и материалов этой модели
и загрузить его в кэш, а девять раз получить указатель на него из кэша.<br>

Правда тут есть один небольшой недостаток. Если первоначально модель была размером 10,
то "ужать" до меньшего размера или увеличить до большего в разных нодах не получится, т.к. 
все ссылаются на одну и ту же модель. Но я так навскидку и не припомню случаев,
когда в играх используются одни и те же модели разного размера.. :\<br>

Можно, конечно, использовать glScale, но тогда почему-то сбаивает освещение...
</p>

<p>Имя модели, котору надо загрузить класс CNode3ds хранит в своей локальной переменной
под именем "MeshName". Класс отслеживает её динамическое изменение,
 чтобы отрисовывать именно ту модель, имя которой хранится в этой переменной.</p>

<p>Встречаются 3ds модели, в которой материалов нет. В этом случае можно
задать материал принудительно, установив локальной переменной с именем "MeshMaterial" имя материала.

<h3 class=header3 align=center>AmberSkyNetVR.dll</h3>
<p>Очень удобно компилировать движок отдельными плагинам, когда отлаживаешь какой-нибудь 
участок кода - тратится меньше времени, чем перекомпилировать полностью все классы. Но вот когда
пишешь прикладную программу, которая этот самый движок использует - тут лучше чтобы всё находилось
в одной dll - как-то некрасиво выглядит кучка этих самых asnEngine.dll, asnNode3ds.dll, итп. 
в дистрибутиве. Поэтому принял решение сделать возможность компиляции всего движка в одну dll.
На функциональность это никак не повлияло, а одна dll занимает меньше места
и выглядит более солидно =) Возможность компиляции плагинов как отдельных dll
так же осталась... </p>


<h3 class=header3 align=center>Изменения в исходниках</h3>

<p>Ммм.. Сложно так все упомнить.. </p>

<p><b>include/:</b> добавлен интерфейс IResourceSystem.h</p>

<p><b>src/asnMain/:</b> небольшая демка с моделями 3ds, позаимствованными из
проекта <a href=http://sourceforge.net/projects/scourge/>S.C.O.U.R.G.E</a>...</b> 
</p>

<p><b>src/asnAll/:</b> добавлена папка с интерфейсом, позволяющим загружать все известные объекты
движка из одного плагина (AmberSkyNetVR.dll) а не с набора разных dll. Для удобства использования.
</p>

<p><b>src/asnCommon/:</b> добавлен класс CNode - основа для прочих узлов сцены.
</p>

<p><b>src/asnEngine/:</b> добавлен менеджер ресурсов.
</p>

<p><b>src/asnWorld/:</b> новый плагин - плагин реализации простейшего менеджера мира CSimpleWorld.
</p>

<p><b>src/asnNode3ds/:</b> новый плагин - первый плагин узла сцены, рисующий 3ds модели.</p>

<p align=center><img src=engine_8.png></p>

<p>Исходники этого шага выложены в SVN. Скачать их можно набрав команду:
<pre>
<b>svn co https://svn.sourceforge.net/svnroot/ambernet/tags/AmberSkyNet-0.8 ambernet_0.8</b>
</pre>

</table>
<div>Powered by:
<A href="http://sourceforge.net"><IMG align=center src="http://sourceforge.net/sflogo.php?group_id=121759&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo" /></A>
</div>

</body>
</html>