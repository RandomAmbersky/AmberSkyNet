<!---                               +                                      --->
<html>
<head>
<title>[ AmberSkyNet VR ]</title>
<link rel=stylesheet type=text/css href=../ambernet.css>
</style>
</head>
<body>
<center>
<table width=80%><tr><td>
<h1 class=header1 align=center>[ AmberSkyNet VR ]</h1>
<blockquote>
</blockquote>

<p>Итак, начнём разработку собственно классов движка.
И начнём с главного класса, на который можно будет постепенно наращивать
классы менеджеров и сцен различной конфигурации</p>

<p>В начале, конечно, полагается прикинуть какие классы
мы будем использовать и нарисовать примерную схему классов (хорошо в
виде UML-диаграммы) но в данном случае схема классов
будет строится по ходу разработки самого движка :) Это наложит отпечаток
как на архитектуру так и на функционал самих классов<p>

<p>Т.к. схемы  нет и мы не можем сказать какие классы еще появятся
и какие переменные в них мы будем использовать, то напишем базовый класс
с учётом лёгкого добавления указателей
на классы и переменных окружения. Конечно, если мы выигрываем в универсальности,
но и теряем в чем-то.. Например - в быстродействии и несколько суживаем
возможности оптимизации.
</p>

<h3 class=header3 align=center>IEngine</h3>

<p>Напишем для начала простенький интерфейс к главному классу под названием IEngine, чтобы не тащить
описание внутреннего устройства нашего класса в прочие. 
Да и править сам CEngine будет проще - не надо адаптировать все остальные
классы к его изменениям.
</p>

<p>Для начала в IEngine опишем всего лишь универсальные операции установки переменных
окружения и указателей на различные менеджеры.
Потом, конечно, функционал расширится. Наверное..<br>
У всех хранимых переменных тип будет std::string. Ну, string в общем..<br>
Я не хочу делать на основе стандартного string'а свой класс, 
а далее планирую написать набор (возможно инлайновых) функций-конвертеров из string'а
 в bool, float, int.
</p>

<p>Указатели будем хранить типа void*. Это может указывать на что угодно,
контроля нет, и если, скажем, мы установили указатель на менеджер сцены,
а читаем его как менеджер звука, то всё может рухнуть со страшной силой :)<br>
Но пока не вижу причину делать отслеживание таких вещей - если смотреть что
устанавливаешь и что читаешь, таких проблем не возникает.<br>
(и вообще, при использовании умных указателей они заимствуют свой ум у программиста... :p Шучу, шучу..)
</p>

<h3 class=header3 align=center>CEngine</h3>
<p>Внутреннюю реализацию переменных окружения сделал через std::map&lt;string,string&gt;.
Потом может быть заменю на специальный класс, который бы при изменении
какого-нибудь параметра запускал бы ф-цию обработки этого изменения (например -
установили переменной ScreenWH значение "800x600" и у нас запустилась
функция смены разрешения экрана).
</p>

<p>Исходники этого шага выложены в SVN. Скачать их можно набрав команду:
<pre>
<b>svn co https://svn.sourceforge.net/svnroot/ambernet/tags/AmberSkyNet-0.2 ambernet_0.2</b>
</pre>
В main.cpp мы создаём экземпляр класса CEngine и пробуем устанавливать,
читать и удалять указатели и переменные окружения движка.
Main.cpp видит экземпляр как IEngihe, но "знает" про CEngine.
Далее планирую отучить его от этой пагубной привычки путём введения классов поддержки
плагинов, и тогда вынесем CEngine в отдельную DLL, оставив в main.cpp
только #include "IEngine.h";
</p>

<p><i>P.S. ну или в отдельную so, я помню про линуксоидов..</i></p>

</table>
<div>Powered by:
<A href="http://sourceforge.net"><IMG align=center src="http://sourceforge.net/sflogo.php?group_id=121759&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo" /></A>
</div>

</body>
</html>