<!---                               +                                      --->
<html>
<head>
<title>[ AmberSkyNet VR ]</title>
<link rel=stylesheet type=text/css href=../ambernet.css>
</style>
</head>
<body>
<center>
<table width=80%><tr><td>
<h1 class=header1 align=center>[ AmberSkyNet VR ]</h1>
<blockquote>
</blockquote>

<p>Продолжаем... Неспеша... Как там у Исссы - "тихо-тихо ползи, Улитка, по склону Фудзи.."
</p>

<p>Пора делать парсинг ini-файла. Файла, в котором
будут храниться всякие настройки - графические, сетевые, игровые.
Пора и нам сделать такой файл.. Его местом расположения
будет та папка, в которой лежит AmberSkyNet.exe, т.к. на момент
старта программы нам неизвестны другие пути.<br>
В констукторе класса Engine сделаем вызов функции разбора ini-файла.
Т.к. эта операция однократная (или двукратная, если разбираются два
ini-файла, - один из которых хранит настройки по умолчанию, а другой-
текущие настройки ) то я не стал делать эту функцию членом класса
Engine а просто вынес отдельно. И кроме CEngine её никто не видит.<br>
Функция открывает ini-файл как файловый поток и построчно читает его,
потом определяет что прочитали - комментарий (начинается с символа ';'),
название раздела (начинается с символа '['), параметр=значение
(присутствует символ '=') или просто пустую строку.<br>
</p>
<p>
Вообще, планировал написать универсальный интерфейс парсера,
одним из парсеров был бы парсер ini-файлов, но потом передумал.
</p>

<p>Я не стал делать отдельный класс для хранения структуры ini-файла.
Оно выглядит красиво, но по-моему не очень нужно, т.к. переменных
окружения не так уж и много, чтобы хранить их еще и иерархически.<br>
При разборе ini-файла название раздела будет присоединяться к названию
параметра и в таком виде заноситься в переменные окружения
класса Engine.</p>

<p>Например в ini-файле есть следующие строки:<br>

<pre><b>
...
[Video]
Screen=800x600
MouseSens_X=150
MouseSens_Y=150
...
</b></pre>

Тогда после разбора ini-файла классом CEngine мы можем читать
эти параметры во внешней программе следующим образом:

<pre><b>
ENGINE->GetPtrParam("[Video]Screen");
ENGINE->GetPtrParam("[Video]MouseSens_X");
ENGINE->GetPtrParam("[Video]MouseSens_Y");
</b></pre>

<p>После разбора ini-файла в конструкторе CEngine можно создавать
различные менеджеры, подавая им на вход требуемый им путь или указатель
на Engine (в этом случае они будут сами читать переменные окружения 
и в зависимости от их значений инициализироваться сами).

</p>

<h3 class=header3 align=center>Изменения в исходниках</h3>

<p><b>include/:</b> Добавлен файл EngineStarter.h для "автоматической"
загрузки модуля asnEngine.dll. Теперь к классу Engine можно обращаться
используя макрос ENGINE (да, мне понравилось решение
в <a href=http://www.gamedev.ru/community/save/>SAVEngine</a> 8), но у меня Engine вынесено в отдельный от Main модуль,
поэтому обращаться напрямую к нему не получится - надо сначала загрузить 
asnEngine.dll).
</p>

<p><b>src/asnCommon/:</b> В файле утилитарных функций
добавлена функция Trim - отбрасывание пробелов в начале и конце строки</p>

<p><b>src/asnMain/:</b> Класс загрузки плагинов вынесен в asnEngine.
Указатель  на экземпляр класса движка получаем через
использование макроса ENGINE.
</p>

<p><b>src/asnEngine/:</b> Сюда перенесен класс загрузки плагинов.
Класс CEngine разбирает ini-файл и создаёт экземпляр класса загрузки плагинов.
Загружаемый модуль asnEngine.dll создаётся в папке bin/, а не в папке
plugins/.
</p>

<p>Исходники этого шага выложены в SVN. Скачать их можно набрав команду:
<pre>
<b>svn co https://svn.sourceforge.net/svnroot/ambernet/tags/AmberSkyNet-0.4 ambernet_0.4</b>
</pre>

</table>
<div>Powered by:
<A href="http://sourceforge.net"><IMG align=center src="http://sourceforge.net/sflogo.php?group_id=121759&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo" /></A>
</div>

</body>
</html>