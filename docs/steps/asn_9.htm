<!---                               +                                      --->
<html>
<head>
<title>[ AmberSkyNet VR ]</title>
<link rel=stylesheet type=text/css href=../ambernet.css>
</style>
</head>
<body>
<center>
<table width=80%><tr><td>
<h1 class=header1 align=center>[ AmberSkyNet VR ]</h1>

<blockquote>
</blockquote>

<p>Наш движок уже что-то умеет, но это всё приходится формировать руками, в прикладной
программе...  Хорошо бы научить наш класс мира загружать сцены из файла,
а научить его сохранять сцену в файл - просто предел мечтаний.
Вот этим сейчас и займёмся... Хранить всё будем в XML-
формате, т.к. древовидная структура сцены и универсальная система параметров 
неплохо накладываются на него. Для работы я буду использовать tinyXML,
но все-таки напишу отдельный плагин парсера данных, который вызовы этой библиотеки
скроет в своих недрах под неким абстрактным интерфейсом.
</p>

<h3 class=header3 align=center>IDataParser и его реализация СDataParserXML</h3>

<p>IDataParser - интерфейсный класс, который будет обеспечивать некий
универсальный интерфейс для доступа к древовидным структурам. Для внешней
программы под ним может скрываться любой парсер. При желании можно написать
парсер и ini-файлов, и конфигурационных файлов с фигурными скобками, итп..
Но я пока ограничился только XML.
</p>

<pre><b>typedef void* DataLeaf;

class IDataParser {
public:
    virtual ~IDataParser(){}

    virtual DataLeaf StartParse(void *data)=0; <span class=comment>// начало парсинга</span>
    virtual void EndParse()=0; <span class=comment>// конец парсинга</span>

    <span class=comment>// функции разбора данных</span>
    virtual const char *GetLeafName(DataLeaf data)=0;
    virtual DataLeaf GetFirstChildLeaf(DataLeaf data)=0;
    virtual DataLeaf GetNextSiblingLeaf(DataLeaf data)=0;
    virtual asn_List& GetParamList(DataLeaf data)=0;

    <span class=comment>// функции формирования данных</span>
    virtual DataLeaf CreateRootLeaf()=0;
    virtual bool SaveDataTree(const char * FileName )=0;
    virtual DataLeaf AddLeafWithName(DataLeaf parent, const char *LeafName)=0;
    virtual bool SetParam(DataLeaf data, const char * Name, const char * Value )=0;
    
};</b></pre>

<p>StartParse - функция разбирает неупорядоченные символьные данные, которые подаются ей по указателю data
и выдаёт указатель на первый узел сформированной структуры
иерархических данных, с которой уже можно работать.</p>
<p>EndParse - функцию использовать не обязательно, но она предназначена для
окончания работы парсера с данными, полученными через StartParse.</p>
<p>GetLeafName - функция выдаёт имя нашего узла leaf.</p>
<p>GetFirstChild - функция выдаёт первого "потомка" узла leaf.</p>
<p>GetNextSiblingLeaf - функция выдаёт следующего "потомка" одного уровня с узлом leaf.</p>
<p>GetParamList - функция выдаёт список параметров нашего узла leaf.</p>

<p>CreateRootLeaf - создаёт в памяти новую иерархическую структуру и выдаёт
указатель на её первый узел. Это пригодится нам для использования во внешней программе,
чтобы можно было формировать древовидную структуру из внешней программы.</p>

<p>SaveDataTree - функция создаёт на диске файл, в который сохраняет нашу структуру в символьном виде.</p>
<p>AddLeafWithName - функция присоединяет к узлу leaf новый узел с именем LeafName.</p>
<p>SetParam - функция устанавливает в узле leaf параметр с именем Name и значением Value.</p>

<p>Реализация класса СDataParserXML пытается обеспечить этот интерфейс,
используя вызовы tinyXML. Все остальные парсеры я пока писать не стал.
Потом.. может быть.. посмотрим.. Хотя, смысл?</p>

<h3 class=header3 align=center>Модификация IWorld и CWorldSimple</h3>
<p>В интерфейс мира добавим пару функций:

<pre><b>bool LoadWorld(const std::string& FileName)
bool SaveWorld(const std::string& FileName)
</b></pre>

<p>В классе CWorldSimple функция SaveWorld используя рекурсивную процедуру
Node2Leaf (см. файл CWorldSimple.cpp) формирует структуру данных
по всем узлам, начиная с корневого, копируя параметры узлов дерева сцены
в структуру данных, сохраняя порядок их вложенности друг в друга.<br>
Получаемое из узла дерева сцены имя реализации базового класса ( через GetType() )
записывается как параметр с именем "Type".<br>
Значения позиции, размеров, итп.. узлов сцены, получаемые через
соотвествующие функции (getPos(), GetSize()..) переводятся из CVector
в String и тоже записываются как параметры узла c именами "Pos", "Size", итп.<br>
После отображения дерева сцены в структуре данных сбрасываем полученную
структуру на жесткий диск.</p>

<p>Функция LoadWorld загружает файл с диска и начинает его разбор.
На выходе получаем корневой узел. А потом при помощи рекурсивной
функции Leaf2Data класса CDataParserXML 
формируем сцену, согласно порядку вложенности в загруженном файле.<br>
Получаем из текущего узла leaf список параметров через GetParamList.<br>
Читаем параметр "Type" и просим систему плагинов сформировать нам экземпляр
класса такого типа.<br>
А потом через SetParam устанавливаем параметры из текущего leaf
нашему созданному экземпляру класса.<br>
Параметры "Pos", "Size", итп. переводятся из String в CVector и
передаются в созданный экземпляр класса через соответствующие функции
( setPos(), setSize()... ).<br>
После чего получаем из текущего leaf список дочерних узлов, формируем их
и подсоединяем к текущему leaf.</p>

<p>Например, если прочитанное из узла структуры данных
значение параметра "Type" равно "Node3ds" мы
просим систему плагинов сформировать нам экземпляр класса Node3ds.
А потом устанавливаем ему остальные параметры из того же узла-
в их числе будет и имя 3ds-модели. Класс Node3ds отслеживает
изменение этого параметра и автоматически обновит
свою внутренную структуру. Через функции setPos, setRot, и др.
3ds модель будет ориентирована в пространстве в том же самом
положении, которое было у ней прежде, на момент сохранения сцены в файл.</p>

<p>Таким образом сохранение/загрузка сцены происходит одинаково
для всех классов, скрывающихся за интерфейсом INode, которые составляют
дерево сцены. При разработке новых типов узлов сцены (анимированные модели, скайкуб, партиклы, итд)
нам не придётся переделывать процедуру загрузки/сохранения. Конечно, в том случае,
если класс, наследуемый от INode будет корректно отслеживать
изменения своих параметров :)</p>

<h3 class=header3 align=center>ICamera и реализация CCamera</h3>

<p>На предыдущем шаге код, реализующий камеру у нас находился в прикладной
программе. Практически "вручную" вычислялось перемещение, движение и повороты
камеры, которой и не было фактически. Было бы удобно создать класс, который бы
упростил нашу прикладную программу, взяв на себя реализацию класса камеры.<br>
Возможно, имеет смысл наследовать камеру от INode, или INode придать функционал
камеры или создать класс модификатора, реализующий камеру, ну, я думаю, это впереди.
Для начала - чего-нибудь попроще создать, чтобы работало... 
Как всегда, сначала составляем интерфейс, наследуемый от IBaseObject.<br>
</p>

<pre><b>
class ICamera: public virtual IBaseObject {
public:

virtual void lookAt(const CVector& Pos)=0;

virtual void View()=0;

virtual void MoveForward(const float val)=0;
virtual void MoveStrafe(const float val)=0;
virtual void MoveUp(const float val)=0;

virtual void setPos(const CVector& Pos)=0;
virtual const CVector& getPos() const =0;

virtual void setRotX(const float val)=0;
virtual void setRotY(const float val)=0;

virtual void getRot(float& RotX, float& RotY) const =0;

virtual void lookAtMouse(int Pos_X, int Pos_Y)=0;

};
</b></pre>

<p>Функция lookAt заставляет посмотреть камеру в точку пространства с координатами Pos.</p>

<p>Функция View устанавливает позицию точки обзора камеры и угол наклона вектора обзора камеры.
Фактически, при её вызове мы получаем на экране вид из камеры.</p>

<p>Функции MoveForward, MoveStrafe, MoveUp двигают позицию камеры 
по углу зрения и перпендикулярно углу зрения "вправо" и "вверх" на расстояние val.
Если задавать отрицательные значения val, то получим обратные движения - "назад", "влево", "вниз".</p>

<p>Функции setPos, getPos - устанавливают и читают значение позиции камеры.</p>
<p>Функция getRot позволяет читать два угла поворота камеры,
а функции setRotX, seRotY устанавливают их. Первый угол - угол поворота камеры
в горизонтальной плоскости (0 - 359), второй - угол наклона камеры по вертикальной плоскости (-90 - +90).</p>

<p>Функция lookAtMouse реализует функцию обзора пространства камерой при помощи "мышки".
В неё передаются позиции курсора мышки по X и Y.</p>

<p>Чтобы реализовать простой на первый взгляд код класса CCamera я посмотрел довольно много
разных исходников движков (например - Linderdaum, Frustum, Irrlight), демок от NeHe,
исходников игровых программ. В общем, вроде как заработало то, что хотел и так,
как хотел :)
</p>

<p>При любом изменении углов поворота камеры происходит пересчет векторов взгляда
и перпендикулярных ему - по новым углам вычисляются два кватерниона, 
умножаются друг на друга, результат их произведения переводится в матрицу, из которой
высчитываются собственно векторы направления камеры.</p>

<p>При изменении позиции к вектору, хранящему координаты камеры Pos прибавляется
вектор соответствующего направления, умноженный на расстояние val.

<p>При вызове функции View мы вычисляем матрицу по координатам камеры Pos и
вектору направления камеры Dir, т.е. как бы заставляем смотреть нашу камеру
в точку с координатами Pos+Dir. После чего через вызов DEVICER->SetModelMatrix()
устанавливаем эту матрицу как матрицу вида для нашего окна.</p>


<p>Когда класс камеры был готов, он использовал команды glLoadMatrix, glMultMatrix,
которые принадлежат библиотеке OpenGL, поэтому класс камеры был размещен
в плагине DeviceGL. После того, как в интерфейс IDevice и соотвественно
класс реализации CDeviceGL были добавлены функции, реализующие вызовы
glLoadMatrix, glMultMatrix, надобность использования OpenGl в классе CCamera отпала -
теперь он реализует данные вызовы через функции менеджера графики CDeviceGL. Но пока
из класса плагина CDeviceGl в отдельный плагин я его не стал выносить.
Потом - посмотрим...
</p>

<h3 class=header3 align=center>Изменения в исходниках</h3>

<p><b>include/:</b>BaseObject скрыт в src/Common, классы движка наследуются от него через виртуальное наследование.
Добавлен интерфейс IDataParser.
</p>

<p><b>src/asnCommon/:</b>Добавлены классы кватерниона и матрицы.<br>
Класс CNode переделан на работу с матрицами. При отрисовке объекта вместо вызова команд поворотов и переноса
теперь вызывается команда DEVICER->MultModelMatrix().
</p>

<p><b>src/asnNode3ds/:</b>Класс модицифирован с учётом возможности
работать напрямую с матрицами, аналогично CNode.
</p>

<p><b>src/asnDataParser/:</b> новый плагин - плагин реализации парсера CDataParserXML.
</p>

<p><b>src/asnDeviceGl/:</b> в плагин добавлен класс CCamera. Немного обновлён класс CDeviceGl
с учётом изменений в IDevice - изменения касаются более удобной работы с матрицами
проекции, вида а также с добавлением возможности отслеживания комбинаций клавиш с нажатиями Alt, Ctrl и др.
</p>

<p><b>src/asnMain/:</b> небольшая демка с моделями 3ds, позаимствованными из
проекта <a href=http://sourceforge.net/projects/scourge/>S.C.O.U.R.G.E</a>.<br>
Добавлены элементы CAD-системы 8) - можно добавлять предметы на сцену,
удалять их, изменять их размеры, позицию, углы поворота.. Сохранять сцену в файл World.xml
и загружать из него 8). А файл World.xml вполне можно подредактировать руками в любом текстовом
редакторе.
</p>


<p><b>src/asnWorld/:</b> Добавлена возможность загрузки/сохранения сцены.</b> 
</p>

<p>Исходники этого шага выложены в SVN. Скачать их можно набрав команду:
<pre>
<b>svn co https://svn.sourceforge.net/svnroot/ambernet/tags/AmberSkyNet-0.9 ambernet_0.9</b>
</pre>

</table>
<div>Powered by:
<A href="http://sourceforge.net"><IMG align=center src="http://sourceforge.net/sflogo.php?group_id=121759&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo" /></A>
</div>

</body>
</html>