<!---                               +                                      --->
<html>
<head>
<title>[ AmberSkyNet VR ]</title>
<link rel=stylesheet type=text/css href=../ambernet.css>
</style>
</head>
<body>
<center>
<table width=80%><tr><td>
<h1 class=header1 align=center>[ AmberSkyNet VR ]</h1>

<blockquote>
</blockquote>

<p>Трёхмерные предметы у нас вертятся и летают, и это, конечно, хорошо..
Но например, если мы захотим написать изометрическую игру, или даже совсем двумерную,
то не обязательно в ней использовать трёхмерные модельки.. 
Можно вполне обойтись плоскими картинками, т.е. спрайтами. Реализацией класса,
который бы отрисовывал на сцене спрайты мы сейчас и займёмся.
Возможно, для двумерной или изометрической игры понадобится специализированный класс
мира (интерфейс IWorld), но им мы займёмся несколько позже, если надо будет...
</p>

<h3 class=header3 align=center>CNodeSprite</h3>

<p>Сделаем класс узла сцены, который бы отрисовывал нам спрайт. 
Наследовать его, конечно, будем от базового класса CNode, который реализует
основные функции, общие для всех узлов сцены...</p>

<p>Сразу предусмотрим возможность анимации, чтобы не писать отдельный класс NodeSpriteAnimate,
т.к. в общем-то отрисовка анимации делается простым смещением текстурных координат.<br>
Так же сразу предусмотрим возможность спрайта оставаться всё время повёрнутым к камере (billbord)
для реализации всяких эффектов типа огня, взрывов, облаков... 
</p>

<pre><b>class CNodeSprite: public CNode {
public:
    CNodeSprite(IEngine* engine);
    ~CNodeSprite();

virtual bool LoadResource(); <span class=comment>// загружаем ресурсы</span>
virtual bool Draw(); <span class=comment>// рисуем</span>
virtual char Update(float tms);<span class=comment>// изменяем состояние спрайта на время tms</span>

<span class=comment>// "перехватываем" установку параметров, характерных только для спрайта </span>
virtual void SetParam(const char* param_name,const char* param_value);

protected:

    UINT current_frame; <span class=comment>//текущий анимационный кадр</span>

    UINT Repeat; <span class=comment>// число повторений анимации, 0 - бесконечно</span>
    UINT Anim_Count_X; <span class=comment>// количество кадров, умещающихся в текстуре по X</span>
    UINT Anim_Count_Y; <span class=comment>// количество кадров, умещающихся в текстуре по Y</span>

    UINT Start_Anim; <span class=comment>// номер кадра, с которого начинается анимация</span>
    UINT Count; <span class=comment>// число кадров в анимации</span>
    
    bool Billbord; <span class=comment>// если true - всегда повёрнут к камере</span>
    
    float lifeTime; <span class=comment>// "время жизни" (используется для анимации)</span>
    float *dataBuffer; <span class=comment>// буфер точек и текстурных координат</span>

    IDrawObject *DrawSprite; <span class=comment>// объект для отрисовки спрайта граф.менеджером</span>

    IMaterial *DrawMaterial; <span class=comment>// "материал" спрайта</span>

};</b></pre>

<p>Функция LoadResource предназначена для загрузки ресурсов, которые использует класс спрайта
для отрисовки. Первым делом проверяется значение параметра "Texture" (которое устанавливается
извне через функцию INode::SetParam() ). Если параметр не установлен - функция возвращает true, 
т.к. попытка загрузки ресурсов закончилась ошибкой.<br>
Если имя текстуры уже задано, функция обращается к графическому менеджеру с просьбой создать для неё
динамический объект для отрисовки ( IDevice::AddDrawObject() ). Динамический, т.к. текстурные координаты в нём будут
постоянно меняться в разные моменты времени для разных объектов.<br>
Далее создаётся массив данных, который заполняется значениями, предназначенными для отрисовки
одного прямоугольника, на который натянута текстура. Впоследствии значения текстурных координат этого
массива будут изменяться в функции Update().<br>
Потом в полученном указателе на созданный менеджером графики обьект отрисовки 
IDrawObject устанавливаются указатель на этот массив, смещения в нем текстурных координат, итп..
Но это не всё.. надо подготовить текстуру :)<br>
Пытаемся получить от менеджера графики IDevice материал с именем, совпадающим с именем используемой текстуры
( IDevice->GetMaterial() ). Если такой материал уже кто-то создал - запоминаем указатель на него в 
переменной DrawMaterial, если нет - создаём его ( DEVICER->AddMaterial( TextureName ) ) 
и устанавливаем в нём текстуру и параметры...<br>
Дальше устанавливаем начальные значения переменных отвечающих за отрисовку спрайта
и вызываем функцию Update(), чтобы она расчитала нам первоначальные значения в массиве данных
Возвращем false, т.е. загрузка ресурсов прошла без ошибок.
</p>

<p>Функция Draw устанавливает матрицу вида и отрисовывает спрайт.
Если установлен признак Billbord, то координаты точек в буфере dataBuffer
пересчитываются так, чтобы отрисовываемый прямоугольник был всегда перпендикулярен лучу обзора,
исходящему из камеры.</p>

<p>Функция Update увеличивает переменную LifeTime на величину tms, и если результат
больше параметра "Speed", то уменьшает величиную LifeTime на Speed (т.е. возвращаемся на начало анимации)
и производит пересчёт текстурных координат с учётом заданных параметров
анимации и номера текущего кадра.<br>
Если мы отрисовали полный цикл анимации положенное число раз, то
происходит удаление данного класса.. 
</p>

<h3 class=header3 align=center>Базовые объекты</h3>

<p>В предыдущем шаге мы научили класс мира загружать и сохранять элементы сцены в
виде XML-файлов. Доработаем его немного - введём возможность описания базовых объектов.<br>
Зачем нужны базовые обьекты? Сейчас поясню... 
Скажем, нам надо нарисовать сцену из 10 колонн. Без базовых объектов нам придётся у каждой
из них описывать размеры, текстуру, характеристики материала.. А с базовым объектом
мы один раз (у базового объекта) зададим характеристики общие для всех 10 колонн,
а при формировании сцены просто напишем 10 раз ссылку на базовый объект и текущее положение
колонны. При этом сами базовые обьекты на сцене не рисуются! Их вообще не существует в виде
экземпляров классов. Они представляют собой всего лишь
что-то вроде словаря, по которому получаем полное описание обьекта при его создании.</p>

<p>Добавим функции для поддержки базовых объектов в наш интерфейс мира IWorld
и, соответственно, в его реализацию CWorldSimple:</p>

<p><b>
bool SetBaseObject(const char *ObjName, const char *InitString);<br>
const char *GetBaseObjectParam(const char *ObjName, const char *ParamName);
</b></p>

<p>Функция SetBaseObject задаёт классу IWorld имя базового объекта и его характеристики.
Пока в качестве характеристики я использовал строку инициализации, но никто не мешает
подвесить XML-парсер и туда.. Это позволит нам создавать группу базовых объектов
вызовом одной функци createNode. Но это возможно в будущем, если возникнет такая потребность.
Пока же - строка инициализации, которая выглядит так:</p>

<p><b>Параметр=Значение;Параметр=Значение;...Параметр=Значение;</b></p>

<p>Функцию LoadWorld доработаем так, чтобы она различала секции описания базовых объектов
и описания самого мира. В XML-файле может быть такое содержимое:</p>

<pre><b>&lt;?xml version="1.0" ?&gt;
&lt;file Name="FileName" /&gt;
...
&lt;BaseObject &gt;
    &lt;BaseName Type="BaseType" ParamName="ParamValue" ... &gt;
    ...
&lt;/BaseObject &gt;
&lt;World&gt;
    &lt;NodeType ParamName="ParamValue" ... &gt;
    ...
&lt;/World&gt;

</b></pre>


<li><b>file</b> - если парсер встречает этот узел xml-дерева, то пытается загрузить файл с именем FileName.
Таким образом одним вызовом функции LoadWorld мы можем подгружать все необходимые файлы для сцены.

<p>Общий список базовых обьектов мира мы можем вынести в отдельный XML-файле, который будем подключать
к разным сценам. Не обязательно подключать этот список "вручную", 
можно прописать в XML-файле описания сцены строчку <b>&lt;file Name="FileName" /&gt;</b>,
где FileName - имя файла, в котором описаны наши базовые объекты. При разборе XML-файла
нашей карты парсер обнаружит эту строчку и подгрузит в мир данные из файла с именем FileName.
А некоторые базовые объекты будут общими для всех наших миров (например - логотипы SDL, OpenGL
и AmberSkyNetVR ).<br>
</p>

<li><b>BaseObject</b> - секция описания базовых объектов.<br>
BaseName - имя базового объекта, при помощи которого на него будут ссылаться в файле сцены<br>
Type - название класса базового объекта. Экземпляр класса с таким именем попытается создать
наш менеджер плагинов.<br>
Имена остальных параметров различны для разных классов...
</p>

<p>Например вот так выглядит описание логотипа AmberSkyNet в базовой секции:<br>

<pre>
&lt;LogoAmberSkyNet Type="NodeSprite" Texture="AmberSkyNet.png" 
	  Size="5 5 5" Billbord="1" Repeat="0" /&gt;</pre>

</p>

<li><b>World</b> - секция описания непосредственно самого мира. Возможно, впоследствии эта секция
будет разделена на сцены, но пока у нас мир представляет собой одну сцену...<br>
NodeType - либо название базового объекта, либо название экземпляра базового класса,
который будет создан менеджером плагинов. При разборе XML-файла парсер сначала
ищет данное имя в списке своих базовых обьектов. Если в списке базовых объектов такое название
отсутствует, то парсер воспримет NodeTypr как имя класса узла сцены и вызовет
у менеджера плагинов функцию создания класса с таким именем.<br>
Например, если мы захотим в сцене увидеть логотип AmberSkyNet в точке 100,100,100 мы можем
написать в секции описания мира строчку:<br>
<pre>
   &lt;LogoAmberSkyNet Pos="10 10 10" /&gt;</pre>
</p>

<h3 class=header3 align=center>Интерфейс менеджер звуков ISound и его реализация CSoundSDL_mixer</h3>

<p>Анимационные взрывы нам надо озвучивать, а наш движок пока молчит.. Пора делать менеджер
звука. Повременим пока с трёхмерным звуком, пусть у нас менеджер делает 2 вещи - играет постоянно фоновую
музыку и однократно играет эффект. Интерфейс будет простой:</p>

<pre><b>
class ISound {
public:
    virtual ~ISound(){}

    virtual bool PlayFX(const char *FxName)=0;
    virtual bool PlayMusic(const char *FxName)=0;
    virtual bool StopMusic()=0;
    

};
</b></pre>


<p>Функция PlayFX запускает воспроизведение звукового эффекта.</p>
<p>Функция PlayMusic начинает воспроизведение фоновой музыки.</p>
<p>Функция StopMisuc останавливает воспроизведение фоновой музыки.</p>

<p>Класс CSoundSDL_mixer, как ясно из его названия, реализует функции этого интерфейса
при помощи библиотеки SDL_mixer. Но ничего не мешает написать свой менеджер звука,
использующий совсем другую звуковую библиотеку.</p>

<h3 class=header3 align=center>Изменения в исходниках</h3>

<p><b>include/:</b> Убран интерфейс менеджера плагинов, который теперь скрыт в недрах IEngine.
Создание объектов теперь производится через вызов IEngine->CreateObject.<br>
Добавлен интерфейс менеджера звуков ISound, изменён интерфейс IWorld c учётом реализации
базовых объектов.<br>
Добавлен класс CBoundBox.h (для вычисления границ нод и проверки на столковения
узла сцены с отрезком).
</p>

<p><b>src/asnCSoundSDL_mixer/:</b> Новый плагин - менеджер звука.</p>

<p><b>src/asnDeviceGl/:</b> В плагин добавлена поддержка текстурных шрифтов,
а так же отслеживание событий выхода/входа курсора мышки в пределы окна, сворачивание окна, итп...
А еще функция MakeScreenshot заработала - теперь можно делать скриншоты
формата bmp.<br>
Добавлен код из библитеки Борескова (3dsteps.narod.ru) по загрузке DDS.
</p>

<p><b>src/asnWorld/:</b> Доработаны процедуры загрузки/сохранения сцены с учётом базовых объектов.<br> 
Добавлена функция getNodesByPos(Start, End), выдающая список нод, через BoundBox'ы которых
прошёл отрезок. Это нам пригодится для выбора кликом мышки предмета, летающего по сцене.
</p>

<p><b>src/asnMain/:</b> Небольшая аркадная демка с падающими предметами,
на которые надо быстренько кликнуть мышкой пока они не упали.
Модели по-прежнему позаимствованными из
проекта <a href=http://sourceforge.net/projects/scourge/>S.C.O.U.R.G.E</a>.<br>
</p>

<p>Исходники этого шага выложены в SVN. Скачать их можно набрав команду:
<pre>
<b>svn co https://svn.sourceforge.net/svnroot/ambernet/tags/AmberSkyNet-0.10 ambernet_0.10</b>
</pre>

</table>
<div>Powered by:
<A href="http://sourceforge.net"><IMG align=center src="http://sourceforge.net/sflogo.php?group_id=121759&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo" /></A>
</div>

</body>
</html>