<!---                               +                                      --->
<html>
<head>
<title>[ AmberSkyNet VR ]</title>
<link rel=stylesheet type=text/css href=../ambernet.css>
</style>
</head>
<body>
<center>
<table width=80%><tr><td>
<h1 class=header1 align=center>[ AmberSkyNet VR ]</h1>

<blockquote>
</blockquote>

<p>Я все-таки решил вынести функционал обработки событий из графического менеджера,
несмотря на то, что в SDL эти понятия связаны (хотя бы тем, что без инициализации
графического окна система событий работать не будет). Сейчас поясню зачем - 
есть ситуации, в которых графический менеджер не нужен, а менеджер событий - нужен всегда
(например, в случае запуска приложения, написанного на движке, в качестве сервера, которому
графику выводить совсем не обязательно). Написать отдельный класс, в котором функции
графического менеджера будут представлены заглушками, конечно, можно.. Но проще
разнести функционал обработки событий и вывода графики по разным классам, а точнее, выделить
обработку событий из менеджера графики в отдельный класс.
</p>

<h3 class=header3 align=center>IEventManager</h3>

<pre>
class IEventManager: public IManager {
public:

<span class=comment>// читаем события из очереди</span>
virtual int GetInput()=0;

virtual IEventListener* AddEventListener( const char *ListenerType )=0;
virtual bool AddCustomEventListener( IEventListener *listener )=0;

virtual int getLastKey()=0;
virtual UINT16 getUnicodeKey()=0;
virtual unsigned short getKeyModifier()=0;

};
</pre>

<p>GetInput - функция возвращет нам событие из очереди событий. Пока в виде int, потом, возможно, 
напишу структуру, наподобие той, которая используется в SDL, чтобы иметь возможность
сохранять в файл последовательность событий и загружать из файла. Пригодится
для написания демок, да и в общем-то можно использовать в клиент-серверной архитектуре - 
ловить текущие события, отбирать из них события, генерируемые действиями пользователя (перемещение,
заклинания, операции с вещами) и передавать на сервер.<br>

<p>AddEventListener - при вызове этой функции менеджер событий обращается к менеджеру
плагинов с запросом на создание экземпляра класса с именем ListenerType.</p>

<p>AddCustomEventListerer - функция добавления своего прослушивателя событий.
Можно во внешней программе создать свой класс слушателя событий, наследовав его от IEventListener,
и добавить его в список слушателей событий менеджера событий.</p>

<p>getLastKey - функция возвращает код последней нажатой клавиши (относительно текущего события, конечно).
</p>

<p>getUnicodeKey - функция возвращает код последней нажатой клавиши в unicode-кодировке.
</p>

<p>getKeyModifier - функция возвращает состояние нажатых клавиш-модификаторов (Shift, Alt.. итп)
</p>

<h3 class=header3 align=center>IEventListener</h3>

<pre>
class IEventListener: public virtual IBaseObject  {

    public:
        virtual ~IEventListener(){};
        virtual bool Listen(int Event)=0;

};
</pre>

<p>Интерфейс к "слушателю" событий довольно прост. Интерес представляет только одна функция - 
Listen. Через эту функцию менеджер событий сообщает о текущем событии 
всем слушателям, которые находятся в его списке,
когда у менеджера событий вызывается функция GetInput().</p>

<p>Таким образом вообще все события движка можно обратывать через слушатели событий, 
не анализируя в прикладной программе результат, возвращемый функцией GetInput.</p>

<p>В дальнейшем, возможно, функционал менеджера событий будет расширен (скажем,
добавлением функции генерации событий)..</p>

<h3 class=header3 align=center>INodeModifier</h3>

<p>Над разными узлами сцены чаще всего требуется совершать однотипные операции -
изменение углов поворота, движение в определенных границах.
Мы можем написать классы различных модификаторв, скрывая их под одним интерфейсом - 
интерфейсом модификатора ноды INodeModifier.
</p>

<pre>
class INodeModifier: public virtual IBaseObject {

    public:

        virtual int Modify(INode *node,float tms)=0;
        <span class=comment>// 0 - все ok
        // 1 - модификатор удален
        // 2... - ошибка</span>

};
</pre>

<p>Я сделал так, чтобы при вызове Modify модификатору передавался указатель на узл сцены, которую следует
обработать. Это сделано для того, чтобы оставить возможность обработки одним экземпляром
класса модификатора нескольких узлов сцены.
</p>

<p>Далее напишем класс списка-"упаковки" модификаторов ноды. Это упростит задачу использования
нескольких модификаторов в списке узла сцены.
</p>

<h3 class=header3 align=center>IModifierPack</h3>

<pre>
class IModifierPack: public virtual IBaseObject {

    public:

        virtual UINT AddModifier(INodeModifier* modifier)=0;
        virtual UINT GetModifierCount()=0;
        virtual INodeModifier* GetModifier(UINT id)=0;
        virtual bool DelModifier(UINT id)=0;

        virtual bool Modify(INode *node, float tms)=0;

};
</pre>

<p>AddModifier - функция добавляет модификатор ноды в список и возвращает номер модификатора в списке</p>
<p>GetModifier - функция выдаёт число модификаторов в списке</p>
<p>GetModifier - функция выдаёт указатель на модификатор ноды по его номеру</p>
<p>DelModifier - функция удаляет модификатор из списка и вызывает его деструктор</p>
<p>Modify - при вызове этой функции класса списка модификаторв у всех модификаторов в списке вызывается функция Modify();</p>

<p>Теперь при создании каждой ноды будет создаваться и экземпляр класса списка ее модификаторов.
Получить указатель на него можно вызвав функцию GetPtrParam("ModifierPack").</p>

<p>Возможно, далее этот механизм будет доработан и вместо IModifierPack функции добавления и удаления
модификаторов перейдут в интерфейс INode.</p>

<p>Хорошей традицией становится отсуствие ссылок на версию движка.. =)</p>

</table>
<div>Powered by:
<A href="http://sourceforge.net"><IMG align=center src="http://sourceforge.net/sflogo.php?group_id=121759&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo" /></A>
</div>

</body>
</html>